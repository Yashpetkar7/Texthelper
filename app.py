{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ff0cc87b-3703-40c3-b63a-32032952b51e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Text Helper Streamlit App — Files\n",
    "\n",
    "Below are all files needed for the Streamlit app. Copy each file into your project folder and run `streamlit run app.py`.\n",
    "\n",
    "---\n",
    "\n",
    "## `app.py`\n",
    "\n",
    "```python\n",
    "import streamlit as st\n",
    "from pathlib import Path\n",
    "from datetime import datetime\n",
    "import io\n",
    "\n",
    "from text_utils import (\n",
    "    to_upper,\n",
    "    to_lower,\n",
    "    strip_text,\n",
    "    replace_text,\n",
    "    count_substring,\n",
    "    get_preview_lines,\n",
    "    get_stats,\n",
    "    validate_extension,\n",
    "    make_timestamp,\n",
    "    convert_text_for_format,\n",
    ")\n",
    "\n",
    "st.set_page_config(page_title=\"Text Helper\", layout=\"wide\")\n",
    "\n",
    "st.title(\"Text Helper — small but powerful\")\n",
    "st.markdown(\"A simple, professional and intuitive dashboard to preview and edit `.txt` files.\")\n",
    "\n",
    "# Sidebar controls\n",
    "with st.sidebar:\n",
    "    st.header(\"Upload & Mode\")\n",
    "    uploaded = st.file_uploader(\"Upload a .txt file\", type=[\"txt\", \"md\", \"html\", \"csv\"], help=\"Only plain text files are recommended. Non-.txt uploads will be rejected for processing unless converted.\")\n",
    "    mode = st.radio(\"Open mode\", [\"Read\", \"Append\"], index=0, help=\"Read: preview and transform (no save). Append: add extra text and save.)\")\n",
    "    st.markdown(\"---\")\n",
    "    st.header(\"Download / Convert\")\n",
    "    target_format = st.selectbox(\"Save as format\", [\".txt\", \".md\", \".html\", \".csv\"], index=0)\n",
    "    st.info(\"Note: conversion is a simple format wrapper — e.g., .html wraps the text in &lt;pre&gt; and .csv places each original line in a row.\")\n",
    "\n",
    "# Validate upload\n",
    "if uploaded is None:\n",
    "    st.info(\"Please upload a .txt file to begin.\")\n",
    "    st.stop()\n",
    "\n",
    "# Keep original filename where possible\n",
    "orig_name = Path(uploaded.name).stem\n",
    "suffix = Path(uploaded.name).suffix.lower()\n",
    "\n",
    "# Enforce .txt input acceptance: allow other text-like files but show clear message\n",
    "if not validate_extension(suffix, allowed_exts=[\".txt\"]):\n",
    "    st.error(\"Only .txt files are supported for processing. If you uploaded a different text file (e.g., .md, .html, .csv) convert it locally first or re-upload a .txt file.\")\n",
    "    st.stop()\n",
    "\n",
    "# Read text from uploaded file\n",
    "raw_bytes = uploaded.read()\n",
    "try:\n",
    "    text = raw_bytes.decode(\"utf-8\")\n",
    "except Exception:\n",
    "    # fallback\n",
    "    text = raw_bytes.decode(\"latin-1\")\n",
    "\n",
    "# Session state to persist edits\n",
    "if \"text\" not in st.session_state:\n",
    "    st.session_state.text = text\n",
    "\n",
    "col1, col2 = st.columns([2, 1])\n",
    "\n",
    "with col1:\n",
    "    st.subheader(\"Preview (first 20 lines)\")\n",
    "    preview_lines = get_preview_lines(st.session_state.text, 20)\n",
    "    st.code(\"\\n\".join(preview_lines), language=None)\n",
    "\n",
    "    st.subheader(\"String tools\")\n",
    "    # Replace inputs\n",
    "    replace_old = st.text_input(\"Replace - old substring\", value=\"\")\n",
    "    replace_new = st.text_input(\"Replace - new substring\", value=\"\")\n",
    "\n",
    "    # Count input\n",
    "    count_sub = st.text_input(\"Count occurrences of substring\", value=\"\")\n",
    "\n",
    "    # Buttons in a compact layout\n",
    "    b1, b2, b3 = st.columns(3)\n",
    "    if b1.button(\"UPPERCASE\"):\n",
    "        st.session_state.text = to_upper(st.session_state.text)\n",
    "        st.success(\"Converted to UPPERCASE\")\n",
    "    if b2.button(\"lowercase\"):\n",
    "        st.session_state.text = to_lower(st.session_state.text)\n",
    "        st.success(\"Converted to lowercase\")\n",
    "    if b3.button(\"strip\"):\n",
    "        st.session_state.text = strip_text(st.session_state.text)\n",
    "        st.success(\"Leading/trailing spaces removed\")\n",
    "\n",
    "    b4, b5 = st.columns(2)\n",
    "    if b4.button(\"replace\"):\n",
    "        if replace_old == \"\":\n",
    "            st.warning(\"Please provide the 'old' substring to replace.\")\n",
    "        else:\n",
    "            st.session_state.text = replace_text(st.session_state.text, replace_old, replace_new)\n",
    "            st.success(f\"Replaced all occurrences of '{replace_old}' with '{replace_new}'.\")\n",
    "\n",
    "    if b5.button(\"count\"):\n",
    "        if count_sub == \"\":\n",
    "            st.warning(\"Please enter a substring to count.\")\n",
    "        else:\n",
    "            cnt = count_substring(st.session_state.text, count_sub)\n",
    "            st.info(f\"Substring '{count_sub}' appears {cnt} times.\")\n",
    "\n",
    "    # Live editable textarea preview\n",
    "    st.subheader(\"Full text (editable preview)\")\n",
    "    st.text_area(\"Edit text directly\", value=st.session_state.text, height=300, key=\"edit_area\")\n",
    "    # Keep session_state.text in sync with edit_area\n",
    "    if st.session_state.edit_area != st.session_state.text:\n",
    "        st.session_state.text = st.session_state.edit_area\n",
    "\n",
    "with col2:\n",
    "    st.subheader(\"Stats\")\n",
    "    line_count, word_count, char_count = get_stats(st.session_state.text)\n",
    "    st.metric(\"Lines\", line_count)\n",
    "    st.metric(\"Words\", word_count)\n",
    "    st.metric(\"Characters\", char_count)\n",
    "\n",
    "    st.markdown(\"---\")\n",
    "    st.subheader(\"Save / Append\")\n",
    "    if mode == \"Read\":\n",
    "        st.info(\"Saving is disabled in Read mode.\")\n",
    "    else:\n",
    "        extra = st.text_area(\"Extra text to append (will be placed after processed text)\", height=150)\n",
    "        if st.button(\"Save & Download\"):\n",
    "            # Compose final content\n",
    "            final_text = st.session_state.text\n",
    "            if extra.strip() != \"\":\n",
    "                final_text = final_text + \"\\n\" + extra\n",
    "            final_text = final_text + \"\\n\\nProcessed on: \" + make_timestamp()\n",
    "\n",
    "            # Convert for chosen format\n",
    "            content_bytes, download_name = convert_text_for_format(final_text, orig_name, target_format)\n",
    "\n",
    "            st.success(\"File ready — click the download button below.\")\n",
    "            st.download_button(\"Download edited file\", data=content_bytes, file_name=download_name)\n",
    "\n",
    "st.markdown(\"---\")\n",
    "st.caption(\"Built with Streamlit — functions are in `text_utils.py`. For local run: `pip install -r requirements.txt` then `streamlit run app.py`.\")\n",
    "```\n",
    "\n",
    "---\n",
    "\n",
    "## `text_utils.py`\n",
    "\n",
    "```python\n",
    "from pathlib import Path\n",
    "from datetime import datetime\n",
    "import io\n",
    "import csv\n",
    "\n",
    "# --- Pure helper functions for string ops ---\n",
    "\n",
    "def to_upper(text: str) -> str:\n",
    "    return text.upper()\n",
    "\n",
    "\n",
    "def to_lower(text: str) -> str:\n",
    "    return text.lower()\n",
    "\n",
    "\n",
    "def strip_text(text: str) -> str:\n",
    "    # strip leading/trailing whitespace on each line and the whole text\n",
    "    lines = [line.strip() for line in text.splitlines()]\n",
    "    return \"\\n\".join(lines).strip()\n",
    "\n",
    "\n",
    "def replace_text(text: str, old: str, new: str) -> str:\n",
    "    return text.replace(old, new)\n",
    "\n",
    "\n",
    "def count_substring(text: str, sub: str) -> int:\n",
    "    if sub == \"\":\n",
    "        return 0\n",
    "    return text.count(sub)\n",
    "\n",
    "\n",
    "def get_preview_lines(text: str, n: int = 20) -> list:\n",
    "    lines = text.splitlines()\n",
    "    # If file shorter than n, return what we have\n",
    "    if len(lines) == 0:\n",
    "        return [\"\"]\n",
    "    return lines[:n]\n",
    "\n",
    "\n",
    "def get_stats(text: str) -> tuple:\n",
    "    lines = text.splitlines()\n",
    "    line_count = len(lines)\n",
    "    word_count = sum(len(line.split()) for line in lines)\n",
    "    char_count = len(text)\n",
    "    return line_count, word_count, char_count\n",
    "\n",
    "\n",
    "def validate_extension(suffix: str, allowed_exts=None) -> bool:\n",
    "    if allowed_exts is None:\n",
    "        allowed_exts = [\".txt\"]\n",
    "    return suffix.lower() in [e.lower() for e in allowed_exts]\n",
    "\n",
    "\n",
    "def make_timestamp(fmt: str = \"%Y-%m-%d %H:%M:%S\") -> str:\n",
    "    return datetime.now().strftime(fmt)\n",
    "\n",
    "\n",
    "def convert_text_for_format(text: str, base_name: str, target_format: str):\n",
    "    \"\"\"\n",
    "    Returns tuple (bytes, filename) for download. Supports .txt, .md, .html, .csv\n",
    "    - .txt/.md: raw text\n",
    "    - .html: wraps into <pre> so linebreaks preserved\n",
    "    - .csv: writes each original line as a CSV row (single column)\n",
    "    \"\"\"\n",
    "    ext = target_format.lower()\n",
    "    if not ext.startswith('.'):\n",
    "        ext = '.' + ext\n",
    "    filename = f\"{base_name}_edited{ext}\"\n",
    "\n",
    "    if ext in ['.txt', '.md']:\n",
    "        b = text.encode('utf-8')\n",
    "        return b, filename\n",
    "    elif ext == '.html':\n",
    "        html = f\"<html><head><meta charset=\\\"utf-8\\\"></head><body><pre>\\n{text}\\n</pre></body></html>\"\n",
    "        return html.encode('utf-8'), filename\n",
    "    elif ext == '.csv':\n",
    "        # Create CSV in memory\n",
    "        buffer = io.StringIO()\n",
    "        writer = csv.writer(buffer)\n",
    "        for line in text.splitlines():\n",
    "            writer.writerow([line])\n",
    "        return buffer.getvalue().encode('utf-8'), filename\n",
    "    else:\n",
    "        # fallback to txt\n",
    "        return text.encode('utf-8'), f\"{base_name}_edited.txt\"\n",
    "```\n",
    "\n",
    "---\n",
    "\n",
    "## `requirements.txt`\n",
    "\n",
    "```\n",
    "streamlit>=1.22\n",
    "```\n",
    "\n",
    "---\n",
    "\n",
    "## `README.md`\n",
    "\n",
    "```md\n",
    "# Text Helper — Streamlit App\n",
    "\n",
    "Small Streamlit app to preview, transform and optionally append & save .txt files.\n",
    "\n",
    "### Features\n",
    "- Upload and validate `.txt` files (friendly error if not `.txt`).\n",
    "- Two modes: Read (no saving) and Append (append extra text and save).\n",
    "- Preview first 20 lines, plus line/word/character stats.\n",
    "- String tools: UPPERCASE, lowercase, strip, replace, count.\n",
    "- Save and download edited file with timestamp.\n",
    "- Convert/save as `.txt`, `.md`, `.html`, or `.csv`.\n",
    "\n",
    "### Run locally\n",
    "1. `python -m venv .venv && source .venv/bin/activate` (or Windows equivalents)\n",
    "2. `pip install -r requirements.txt`\n",
    "3. `streamlit run app.py`\n",
    "\n",
    "```\n",
    "\n",
    "---\n",
    "\n",
    "## Notes & small improvements you can make\n",
    "\n",
    "* If you want richer conversions (e.g., `.docx` or `.pdf`) add `python-docx` or `pdfkit` and update `convert_text_for_format`.\n",
    "* For extremely large files, consider streaming or truncating the in-memory reads.\n",
    "* The UI is intentionally compact; feel free to tweak layout and styles.\n",
    "\n",
    "---\n",
    "\n",
    "If you'd like, I can also provide a single ZIP file with these files or convert the app to include extra features (e.g., regex replace, preview highlight).\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
